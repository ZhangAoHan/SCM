// DES加解密算法Dlg.cpp : implementation file
//

#include "stdafx.h"
#include "DES加解密算法.h"
#include "DES加解密算法Dlg.h"
#include "math.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDESDlg dialog

CDESDlg::CDESDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDESDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDESDlg)
	m_MINGWEN =_T("");
	m_MEWEN = _T("");
	m_YUANWEN = _T("");
	m_MIYAO = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CDESDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDESDlg)
	DDX_Text(pDX, IDC_EDIT1, m_MINGWEN);
	DDV_MaxChars(pDX, m_MINGWEN, 8);
	DDX_Text(pDX, IDC_EDIT2, m_MEWEN);
	DDX_Text(pDX, IDC_EDIT3, m_YUANWEN);
	DDX_Text(pDX, IDC_EDIT4, m_MIYAO);
	DDV_MaxChars(pDX, m_MIYAO, 8);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDESDlg, CDialog)
	//{{AFX_MSG_MAP(CDESDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_JIEMIBUTTON, OnJiemibutton)
	ON_BN_CLICKED(IDC_JMBUTTON, OnJmbutton)
	ON_BN_CLICKED(IDC_TCHBUTTON, OnTchbutton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDESDlg message handlers

BOOL CDESDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
   
	// Add "About..." menu item to system menu.
	m_MINGWEN="tsinghua";
	m_MIYAO="computer";
	UpdateData(false);//今后注意，在初始化里改变默认设置，改完后一定要刷新
    // IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDESDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDESDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDESDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CDESDlg::OnJiemibutton() 
{
	// TODO: Add your control notification handler code here
	DESJIEMI();
}

void CDESDlg::OnJmbutton() 
{
	// TODO: Add your control notification handler code here
	UpdateData(true);
    initial();
	DESDIEDAI();
}

void CDESDlg::OnTchbutton() 
{
	// TODO: Add your control notification handler code here
	exit(0);
}

void CDESDlg::Mingwenerjinzhi()
{
	FILE *fp;
	char ch;
	static int i,j,str[8];

	fp=fopen("明文二进制表示.dat","w");
	for(i=0;i<8;i++)
	{
	  ch=m_MINGWEN.GetAt(i);
	  for(j=0;j<8;j++)
	  {
         str[j]=ch%2;
		 ch=ch/2;
	  }
	  for(j=7;j>=0;j--)
	    fprintf(fp,"%d\n",str[j]);
	}
	fclose(fp);
} 

void CDESDlg::MIYAOERJINZHI()
{
    FILE *fp;
	char ch;
	static int i,j,str[8];

	fp=fopen("密钥二进制表示.dat","w");
	for(i=0;i<8;i++)
	{
	  ch=m_MIYAO.GetAt(i);
	  for(j=0;j<8;j++)
	  {
         str[j]=ch%2;
		 ch=ch/2;
	  }
	  for(j=7;j>=0;j--)
	    fprintf(fp,"%d\n",str[j]);
	}
	fclose(fp);
}

void CDESDlg::initial()//生成明文的IP和密钥的16个子密钥
{
	FILE *fp;
	int m[65],m1[65],k[65],i,k0[57],C[57];
	int C0[29],D0[29],C1[29],D1[29],C2[29],D2[29],C3[29],D3[29],C4[29],D4[29],C5[29],D5[29],C6[29],D6[29],C7[29],D7[29],C8[29],D8[29],C9[29],D9[29],C10[29],D10[29],C11[29],D11[29],C12[29],D12[29],C13[29],D13[29],C14[29],D14[29],C15[29],D15[29],C16[29],D16[29];
    int ip[65]={58,50,42,34,26,18,10,2,
	            60,52,44,36,28,20,12,4,
	            62,54,46,38,30,22,14,6,
	            64,56,48,40,32,24,16,8,
	            57,49,41,33,25,17,9,1,
	            59,51,43,35,27,19,11,3,
	            61,53,45,37,29,21,13,5,
	            63,55,47,39,31,23,15,7}; 
	int PC_1[57]={57,49,41,33,25,17,9,
	              1,58,50,42,34,26,18,
	              10,2,59,51,43,35,27,
	              19,11,3,60,52,44,36,
	              63,55,47,39,31,23,15,
	              7,62,54,46,38,30,22,
	              14,6,61,53,45,37,29,
	              21,13,5,28,20,12,4};
	int PC_2[49]={14,17,11,24,1,5,
                  3,28,15,6,21,10,
	              23,19,12,4,26,8,
	              16,7,27,20,13,2,
	              41,52,31,37,47,55,
	              30,40,51,45,33,48,
	              44,49,39,56,34,53,
	              46,42,50,36,29,32};
	Mingwenerjinzhi();
	MIYAOERJINZHI();
    fp=fopen("明文二进制表示.dat","r");
 	for(i=1;i<=64;i++)    
      fscanf(fp,"%d\n",&m[i]);
	fclose(fp);
    fp=fopen("密钥二进制表示.dat","r");
	for(i=1;i<=64;i++)    
      fscanf(fp,"%d\n",&k[i]);
	fclose(fp);
	for(i=1;i<=64;i++)
      m1[i]=m[ip[i-1]];
	for(i=1;i<33;i++)
	  L0[i]=m1[i];//明文左侧的初始化
	for(i=33;i<=64;i++)
      R0[i-32]=m1[i];//明文右侧的初始化
	for(i=1;i<57;i++)//生成子密钥
	  k0[i]=k[PC_1[i-1]];
    for(i=1;i<29;i++)
	  C0[i]=k0[i];
	for(i=29;i<=56;i++)
	  D0[i-28]=k0[i];
    for(i=1;i<28;i++)//循环左移一位
	{
		C1[i]=C0[i+1];
		D1[i]=D0[i+1];
	}
	C1[28]=C0[1];
	D1[28]=D0[1];
	for(i=1;i<=28;i++)
	{
		C[i]=C1[i];
		C[i+28]=D1[i];
	}
	for(i=1;i<=48;i++)
		K1[i]=C[PC_2[i-1]];//生成子密钥k1
    for(i=1;i<28;i++)      //循环左移一位
	{
		C2[i]=C1[i+1];
		D2[i]=D1[i+1];
	}
	C2[28]=C1[1];
	D2[28]=D1[1];
	for(i=1;i<=28;i++)
	{
	  C[i]=C2[i];
	  C[i+28]=D2[i];
	}
	for(i=1;i<=48;i++)
	  K2[i]=C[PC_2[i-1]];//生成子密钥k2
	for(i=1;i<27;i++)//循环左移两位
	{
		C3[i]=C2[i+2];
		D3[i]=D2[i+2];
	}
	C3[27]=C2[1];
	D3[27]=D2[1];
	C3[28]=C2[2];
	D3[28]=D2[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C3[i];
	  C[i+28]=D3[i];
	}
	for(i=1;i<=48;i++)
	  K3[i]=C[PC_2[i-1]];//生成子密钥k3
    for(i=1;i<27;i++)//循环左移两位
	{
		C4[i]=C3[i+2];
		D4[i]=D3[i+2];
	}
	C4[27]=C3[1];
	D4[27]=D3[1];
	C4[28]=C3[2];
	D4[28]=D3[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C4[i];
	  C[i+28]=D4[i];
	}
	for(i=1;i<=48;i++)
	  K4[i]=C[PC_2[i-1]];//生成子密钥k4
	for(i=1;i<27;i++)//循环左移两位
	{
		C5[i]=C4[i+2];
		D5[i]=D4[i+2];
	}
	C5[27]=C4[1];
	D5[27]=D4[1];
	C5[28]=C4[2];
	D5[28]=D4[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C5[i];
	  C[i+28]=D5[i];
	}
	for(i=1;i<=48;i++)
	  K5[i]=C[PC_2[i-1]];//生成子密钥k5
	for(i=1;i<27;i++)//循环左移两位
	{
		C6[i]=C5[i+2];
		D6[i]=D5[i+2];
	}
	C6[27]=C5[1];
	D6[27]=D5[1];
	C6[28]=C5[2];
	D6[28]=D5[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C6[i];
	  C[i+28]=D6[i];
	}
	for(i=1;i<=48;i++)
	  K6[i]=C[PC_2[i-1]];//生成子密钥k6
	for(i=1;i<27;i++)//循环左移两位
	{
		C7[i]=C6[i+2];
		D7[i]=D6[i+2];
	}
	C7[27]=C6[1];
	D7[27]=D6[1];
	C7[28]=C6[2];
	D7[28]=D6[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C7[i];
	  C[i+28]=D7[i];
	}
	for(i=1;i<=48;i++)
	  K7[i]=C[PC_2[i-1]];//生成子密钥k7
	for(i=1;i<27;i++)//循环左移两位
	{
		C8[i]=C7[i+2];
		D8[i]=D7[i+2];
	}
	C8[27]=C7[1];
	D8[27]=D7[1];
	C8[28]=C7[2];
	D8[28]=D7[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C8[i];
	  C[i+28]=D8[i];
	}
	for(i=1;i<=48;i++)
	  K8[i]=C[PC_2[i-1]];//生成子密钥k8
	for(i=1;i<28;i++)      //循环左移一位
	{
		C9[i]=C8[i+1];
		D9[i]=D8[i+1];
	}
	C9[28]=C8[1];
	D9[28]=D8[1];
	for(i=1;i<=28;i++)
	{
	  C[i]=C9[i];
	  C[i+28]=D9[i];
	}
	for(i=1;i<=48;i++)
	  K9[i]=C[PC_2[i-1]];//生成子密钥k9
	for(i=1;i<27;i++)//循环左移两位
	{
		C10[i]=C9[i+2];
		D10[i]=D9[i+2];
	}
	C10[27]=C9[1];
	D10[27]=D9[1];
	C10[28]=C9[2];
	D10[28]=D9[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C10[i];
	  C[i+28]=D10[i];
	}
	for(i=1;i<=48;i++)
	  K10[i]=C[PC_2[i-1]];//生成子密钥k10
	for(i=1;i<27;i++)//循环左移两位
	{
		C11[i]=C10[i+2];
		D11[i]=D10[i+2];
	}
	C11[27]=C10[1];
	D11[27]=D10[1];
	C11[28]=C10[2];
	D11[28]=D10[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C11[i];
	  C[i+28]=D11[i];
	}
	for(i=1;i<=48;i++)
	  K11[i]=C[PC_2[i-1]];//生成子密钥k11
	for(i=1;i<27;i++)//循环左移两位
	{
		C12[i]=C11[i+2];
		D12[i]=D11[i+2];
	}
	C12[27]=C11[1];
	D12[27]=D11[1];
	C12[28]=C11[2];
	D12[28]=D11[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C12[i];
	  C[i+28]=D12[i];
	}
	for(i=1;i<=48;i++)
	  K12[i]=C[PC_2[i-1]];//生成子密钥k12
	for(i=1;i<27;i++)//循环左移两位
	{
		C13[i]=C12[i+2];
		D13[i]=D12[i+2];
	}
	C13[27]=C12[1];
	D13[27]=D12[1];
	C13[28]=C12[2];
	D13[28]=D12[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C13[i];
	  C[i+28]=D13[i];
	}
	for(i=1;i<=48;i++)
	  K13[i]=C[PC_2[i-1]];//生成子密钥k13
	for(i=1;i<27;i++)//循环左移两位
	{
		C14[i]=C13[i+2];
		D14[i]=D13[i+2];
	}
	C14[27]=C13[1];
	D14[27]=D13[1];
	C14[28]=C13[2];
	D14[28]=D13[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C14[i];
	  C[i+28]=D14[i];
	}
	for(i=1;i<=48;i++)
	  K14[i]=C[PC_2[i-1]];//生成子密钥k14
	for(i=1;i<27;i++)//循环左移两位
	{
		C15[i]=C14[i+2];
		D15[i]=D14[i+2];
	}
	C15[27]=C14[1];
	D15[27]=D14[1];
	C15[28]=C14[2];
	D15[28]=D14[2];
	for(i=1;i<=28;i++)
	{
	  C[i]=C15[i];
	  C[i+28]=D15[i];
	}
	for(i=1;i<=48;i++)
	  K15[i]=C[PC_2[i-1]];//生成子密钥k15
	for(i=1;i<28;i++)      //循环左移一位
	{
		C16[i]=C15[i+1];
		D16[i]=D15[i+1];
	}
	C16[28]=C15[1];
	D16[28]=D15[1];
	for(i=1;i<=28;i++)
	{
	  C[i]=C16[i];
	  C[i+28]=D16[i];
	}
	for(i=1;i<=48;i++)
	  K16[i]=C[PC_2[i-1]];//生成子密钥k16
}

void CDESDlg::DESDIEDAI()
{
	int E[49]={32,1,2,3,4,5,
	           4,5,6,7,8,9,
	           8,9,10,11,12,13,
	           12,13,14,15,16,17,
	           16,17,18,19,20,21,
	           20,21,22,23,24,25,
	           24,25,26,27,28,29,
	           28,29,30,31,32,31};
	int P[33]={16,7,20,21,
	           29,12,28,17,
	           1,15,23,26,
	           5,18,31,10,
	           2,8,24,14,
	           32,27,3,9,
	           19,13,30,6,
	           22,11,4,25};
	int L1[33],R1[33],L2[33],R2[33],L3[33],R3[33],L4[33],R4[33],L5[33],R5[33],L6[33],R6[33],L7[33],R7[33],L8[33],R8[33],L9[33],R9[33],L10[33],R10[33],L11[33],R11[33],L12[33],R12[33],L13[33],R13[33],L14[33],R14[33],L15[33],R15[33],L16[33],R16[33];
	int RE1[49];
	int i,s11[7],s21[7],s31[7],s41[7],s51[7],s61[7],s71[7],s81[7];
	int s1[4][16]={14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,
	               0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,
	               4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,
	               15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13};
    int s2[4][16]={15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,
	               3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,
	               0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,
	               13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9};
	int s3[4][16]={10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,
            	   13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,
	               13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,
	               1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12};
	int s4[4][16]={7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,
	               13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,
	               10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,
	               3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14};
	int s5[4][16]={2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,
	               14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,
	               4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,
	               11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3};
	int s6[4][16]={12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,
	               10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,
    	           9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,
	               4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13};
	int s7[4][16]={4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,
	               13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,
	               1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,
	               6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12};
	int s8[4][16]={13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,
	               1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,
	               7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,
	               2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11};
	static int f[33],j;
	int s[9],frk[33],temp[5];
	int IP_1[64]={40,8,48,16,56,24,64,32,
	              39,7,47,15,55,23,63,31,
	              38,6,46,14,54,22,62,30,
	              37,5,45,13,53,21,61,29,
	              36,4,44,12,52,20,60,28,
	              35,3,43,11,51,19,59,27,
	              34,2,42,10,50,18,58,26,
	              33,1,41,9,49,17,57,25};
//进行第一次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R0[E[i-1]];
	for(i=1;i<=48;i++)//与K1按位作不进位加法运算
	  RE1[i]=RE1[i]+K1[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
        RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)
      L1[i]=R0[i];
	for(i=1;i<33;i++)
    {
		R1[i]=L0[i]+frk[i];
		if(R1[i]==2)
          R1[i]=0;
    }
//进行第二次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R1[E[i-1]];
	for(i=1;i<=48;i++)//与K2按位作不进位加法运算
	  RE1[i]=RE1[i]+K2[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L2[i]=R1[i];
	for(i=1;i<33;i++)//R2为L1与f(R,K)进行不进位二进制加法运算结果
    {
		R2[i]=L1[i]+frk[i];
		if(R2[i]==2)
          R2[i]=0;
    }
//进行第三次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R2[E[i-1]];
	for(i=1;i<=48;i++)//与K3按位作不进位加法运算
	  RE1[i]=RE1[i]+K3[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L3[i]=R2[i];
	for(i=1;i<33;i++)//R3为L2与f(R,K)进行不进位二进制加法运算结果
    {
		R3[i]=L2[i]+frk[i];
		if(R3[i]==2)
          R3[i]=0;
    }
//进行第四次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R3[E[i-1]];
	for(i=1;i<=48;i++)//与K4按位作不进位加法运算
	  RE1[i]=RE1[i]+K4[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L4[i]=R3[i];
	for(i=1;i<33;i++)//R4为L3与f(R,K)进行不进位二进制加法运算结果
    {
		R4[i]=L3[i]+frk[i];
		if(R4[i]==2)
          R4[i]=0;
    }
//进行第五次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R4[E[i-1]];
	for(i=1;i<=48;i++)//与K5按位作不进位加法运算
	  RE1[i]=RE1[i]+K5[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L5[i]=R4[i];
	for(i=1;i<33;i++)//R5为L4与f(R,K)进行不进位二进制加法运算结果
    {
		R5[i]=L4[i]+frk[i];
		if(R5[i]==2)
          R5[i]=0;
    }
//进行第六次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R5[E[i-1]];
	for(i=1;i<=48;i++)//与K6按位作不进位加法运算
	  RE1[i]=RE1[i]+K6[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L6[i]=R5[i];
	for(i=1;i<33;i++)//R6为L5与f(R,K)进行不进位二进制加法运算结果
    {
		R6[i]=L5[i]+frk[i];
		if(R6[i]==2)
          R6[i]=0;
    }
//进行第七次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R6[E[i-1]];
	for(i=1;i<=48;i++)//与K7按位作不进位加法运算
	  RE1[i]=RE1[i]+K7[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L7[i]=R6[i];
	for(i=1;i<33;i++)//R7为L6与f(R,K)进行不进位二进制加法运算结果
    {
		R7[i]=L6[i]+frk[i];
		if(R7[i]==2)
          R7[i]=0;
    }
//进行第八次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R7[E[i-1]];
	for(i=1;i<=48;i++)//与K8按位作不进位加法运算
	  RE1[i]=RE1[i]+K8[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L8[i]=R7[i];
	for(i=1;i<33;i++)//R8为L7与f(R,K)进行不进位二进制加法运算结果
    {
		R8[i]=L7[i]+frk[i];
		if(R8[i]==2)
          R8[i]=0;
    }
//进行第九次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R8[E[i-1]];
	for(i=1;i<=48;i++)//与K9按位作不进位加法运算
	  RE1[i]=RE1[i]+K9[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L9[i]=R8[i];
	for(i=1;i<33;i++)//R9为L8与f(R,K)进行不进位二进制加法运算结果
    {
		R9[i]=L8[i]+frk[i];
		if(R9[i]==2)
          R9[i]=0;
    }
//进行第十次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R9[E[i-1]];
	for(i=1;i<=48;i++)//与K10按位作不进位加法运算
	  RE1[i]=RE1[i]+K10[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L10[i]=R9[i];
	for(i=1;i<33;i++)//R10为L9与f(R,K)进行不进位二进制加法运算结果
    {
		R10[i]=L9[i]+frk[i];
		if(R10[i]==2)
          R10[i]=0;
    }
//进行第十一次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R10[E[i-1]];
	for(i=1;i<=48;i++)//与K11按位作不进位加法运算
	  RE1[i]=RE1[i]+K11[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L11[i]=R10[i];
	for(i=1;i<33;i++)//R11为L10与f(R,K)进行不进位二进制加法运算结果
    {
		R11[i]=L10[i]+frk[i];
		if(R11[i]==2)
          R11[i]=0;
    }
//进行第十二次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R11[E[i-1]];
	for(i=1;i<=48;i++)//与K12按位作不进位加法运算
	  RE1[i]=RE1[i]+K12[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L12[i]=R11[i];
	for(i=1;i<33;i++)//R12为L11与f(R,K)进行不进位二进制加法运算结果
    {
		R12[i]=L11[i]+frk[i];
		if(R12[i]==2)
          R12[i]=0;
    }
//进行第十三次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R12[E[i-1]];
	for(i=1;i<=48;i++)//与K13按位作不进位加法运算
	  RE1[i]=RE1[i]+K13[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L13[i]=R12[i];
	for(i=1;i<33;i++)//R13为L12与f(R,K)进行不进位二进制加法运算结果
    {
		R13[i]=L12[i]+frk[i];
		if(R13[i]==2)
          R13[i]=0;
    }
//进行第十四次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R13[E[i-1]];
	for(i=1;i<=48;i++)//与K14按位作不进位加法运算
	  RE1[i]=RE1[i]+K14[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L14[i]=R13[i];
	for(i=1;i<33;i++)//R14为L13与f(R,K)进行不进位二进制加法运算结果
    {
		R14[i]=L13[i]+frk[i];
		if(R14[i]==2)
          R14[i]=0;
    }
//进行第十五次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R14[E[i-1]];
	for(i=1;i<=48;i++)//与K15按位作不进位加法运算
	  RE1[i]=RE1[i]+K15[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L15[i]=R14[i];
	for(i=1;i<33;i++)//R15为L14与f(R,K)进行不进位二进制加法运算结果
    {
		R15[i]=L14[i]+frk[i];
		if(R15[i]==2)
          R15[i]=0;
    }
//进行第十六次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R15[E[i-1]];
	for(i=1;i<=48;i++)//与K16按位作不进位加法运算
	  RE1[i]=RE1[i]+K16[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L16[i]=R15[i];
	for(i=1;i<33;i++)//R16为L15与f(R,K)进行不进位二进制加法运算结果
    {
		R16[i]=L15[i]+frk[i];
		if(R16[i]==2)
          R16[i]=0;
    }
	int t[65]; 
	for(i=1;i<=32;i++)
    {
		t[i]=L16[i];
		t[i+32]=R16[i];
	}
	for(i=1;i<=64;i++)
		t1[i]=t[IP_1[i-1]];
	int ch;
    m_MEWEN="";
	for(i=1;i<=64;i++)
	{
		m_MEWEN=m_MEWEN+(char)(48+t1[i]);
		if(i%8==0)
          m_MEWEN=m_MEWEN+" ";
	}
    UpdateData(false);
}

void CDESDlg::DESJIEMI()
{
  int t2[65],RE1[49],f[33],frk[33];
  int L1[33],R1[33],L2[33],R2[33],L3[33],R3[33],L4[33],R4[33],L5[33],R5[33],L6[33],R6[33],L7[33],R7[33],L8[33],R8[33],L9[33],R9[33],L10[33],R10[33],L11[33],R11[33],L12[33],R12[33],L13[33],R13[33],L14[33],R14[33],L15[33],R15[33],L16[33],R16[33];
  int i,j;
  	int IP_1[64]={40,8,48,16,56,24,64,32,
	              39,7,47,15,55,23,63,31,
	              38,6,46,14,54,22,62,30,
	              37,5,45,13,53,21,61,29,
	              36,4,44,12,52,20,60,28,
	              35,3,43,11,51,19,59,27,
	              34,2,42,10,50,18,58,26,
	              33,1,41,9,49,17,57,25};
  	int P[33]={16,7,20,21,
	           29,12,28,17,
	           1,15,23,26,
	           5,18,31,10,
	           2,8,24,14,
	           32,27,3,9,
	           19,13,30,6,
	           22,11,4,25};
  	int s1[4][16]={14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,
	               0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,
	               4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,
	               15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13};
    int s2[4][16]={15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,
	               3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,
	               0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,
	               13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9};
	int s3[4][16]={10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,
            	   13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,
	               13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,
	               1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12};
	int s4[4][16]={7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,
	               13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,
	               10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,
	               3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14};
	int s5[4][16]={2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,
	               14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,
	               4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,
	               11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3};
	int s6[4][16]={12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,
	               10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,
    	           9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,
	               4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13};
	int s7[4][16]={4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,
	               13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,
	               1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,
	               6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12};
	int s8[4][16]={13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,
	               1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,
	               7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,
	               2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11};
  int E[49]={32,1,2,3,4,5,
	           4,5,6,7,8,9,
	           8,9,10,11,12,13,
	           12,13,14,15,16,17,
	           16,17,18,19,20,21,
	           20,21,22,23,24,25,
	           24,25,26,27,28,29,
	           28,29,30,31,32,31};
  int ip[65]={58,50,42,34,26,18,10,2,
	          60,52,44,36,28,20,12,4,
	          62,54,46,38,30,22,14,6,
	          64,56,48,40,32,24,16,8,
	          57,49,41,33,25,17,9,1,
	          59,51,43,35,27,19,11,3,
	          61,53,45,37,29,21,13,5,
	          63,55,47,39,31,23,15,7};
  int s[9],s11[7],s21[7],s31[7],s41[7],s51[7],s61[7],s71[7],s81[7];
  int temp[5];
  for(i=1;i<=64;i++)
  {
	  t2[i]=t1[ip[i-1]];
  }
  for(i=1;i<33;i++)
  {
	  R0[i]=t2[i];
	  L0[i]=t2[i+32];
  }
//第一次迭代
  for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
    RE1[i]=R0[E[i-1]];
  for(i=1;i<=48;i++)//与K1按位作不进位加法运算
	RE1[i]=RE1[i]+K16[i];
  for(i=1;i<=48;i++)
  {
	if(RE1[i]==2)
      RE1[i]=0;
  }
  for(i=1;i<7;i++)//48位分成8组
  {
	s11[i]=RE1[i];
	s21[i]=RE1[i+6];
	s31[i]=RE1[i+12];
	s41[i]=RE1[i+18];
	s51[i]=RE1[i+24];
	s61[i]=RE1[i+30];
	s71[i]=RE1[i+36];
	s81[i]=RE1[i+42];
  }//下面经过S盒，得到8个数
  s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
  s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
  s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
  s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
  s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
  s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
  s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
  s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
  for(i=0;i<8;i++)//8个数变换输出二进制
  {
 	for(j=1;j<5;j++)
	{
	  temp[j]=s[i+1]%2;
	  s[i+1]=s[i+1]/2;
	}
	for(j=1;j<5;j++)
      f[4*i+j]=temp[5-j];
  }
  for(i=1;i<33;i++)//经过P变换
    frk[i]=f[P[i-1]];
  for(i=1;i<33;i++)
    L1[i]=R0[i];
  for(i=1;i<33;i++)
  {
	R1[i]=L0[i]+frk[i];
	if(R1[i]==2)
      R1[i]=0;
  }
//进行第二次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R1[E[i-1]];
	for(i=1;i<=48;i++)//与K15按位作不进位加法运算
	  RE1[i]=RE1[i]+K15[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L2[i]=R1[i];
	for(i=1;i<33;i++)//R2为L1与f(R,K)进行不进位二进制加法运算结果
    {
		R2[i]=L1[i]+frk[i];
		if(R2[i]==2)
          R2[i]=0;
    }
//进行第三次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R2[E[i-1]];
	for(i=1;i<=48;i++)//与K14按位作不进位加法运算
	  RE1[i]=RE1[i]+K14[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L3[i]=R2[i];
	for(i=1;i<33;i++)//R3为L2与f(R,K)进行不进位二进制加法运算结果
    {
		R3[i]=L2[i]+frk[i];
		if(R3[i]==2)
          R3[i]=0;
    }
//进行第四次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R3[E[i-1]];
	for(i=1;i<=48;i++)//与K13按位作不进位加法运算
	  RE1[i]=RE1[i]+K13[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L4[i]=R3[i];
	for(i=1;i<33;i++)//R4为L3与f(R,K)进行不进位二进制加法运算结果
    {
		R4[i]=L3[i]+frk[i];
		if(R4[i]==2)
          R4[i]=0;
    }
//进行第五次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R4[E[i-1]];
	for(i=1;i<=48;i++)//与K12按位作不进位加法运算
	  RE1[i]=RE1[i]+K12[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L5[i]=R4[i];
	for(i=1;i<33;i++)//R5为L4与f(R,K)进行不进位二进制加法运算结果
    {
		R5[i]=L4[i]+frk[i];
		if(R5[i]==2)
          R5[i]=0;
    }
//进行第六次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R5[E[i-1]];
	for(i=1;i<=48;i++)//与K11按位作不进位加法运算
	  RE1[i]=RE1[i]+K11[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L6[i]=R5[i];
	for(i=1;i<33;i++)//R6为L5与f(R,K)进行不进位二进制加法运算结果
    {
		R6[i]=L5[i]+frk[i];
		if(R6[i]==2)
          R6[i]=0;
    }
//进行第七次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R6[E[i-1]];
	for(i=1;i<=48;i++)//与K10按位作不进位加法运算
	  RE1[i]=RE1[i]+K10[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L7[i]=R6[i];
	for(i=1;i<33;i++)//R7为L6与f(R,K)进行不进位二进制加法运算结果
    {
		R7[i]=L6[i]+frk[i];
		if(R7[i]==2)
          R7[i]=0;
    }
//进行第八次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R7[E[i-1]];
	for(i=1;i<=48;i++)//与K9按位作不进位加法运算
	  RE1[i]=RE1[i]+K9[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L8[i]=R7[i];
	for(i=1;i<33;i++)//R8为L7与f(R,K)进行不进位二进制加法运算结果
    {
		R8[i]=L7[i]+frk[i];
		if(R8[i]==2)
          R8[i]=0;
    }
//进行第九次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R8[E[i-1]];
	for(i=1;i<=48;i++)//与K8按位作不进位加法运算
	  RE1[i]=RE1[i]+K8[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L9[i]=R8[i];
	for(i=1;i<33;i++)//R9为L8与f(R,K)进行不进位二进制加法运算结果
    {
		R9[i]=L8[i]+frk[i];
		if(R9[i]==2)
          R9[i]=0;
    }
//进行第十次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R9[E[i-1]];
	for(i=1;i<=48;i++)//与K7按位作不进位加法运算
	  RE1[i]=RE1[i]+K7[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L10[i]=R9[i];
	for(i=1;i<33;i++)//R10为L9与f(R,K)进行不进位二进制加法运算结果
    {
		R10[i]=L9[i]+frk[i];
		if(R10[i]==2)
          R10[i]=0;
    }
//进行第十一次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R10[E[i-1]];
	for(i=1;i<=48;i++)//与K6按位作不进位加法运算
	  RE1[i]=RE1[i]+K6[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L11[i]=R10[i];
	for(i=1;i<33;i++)//R11为L10与f(R,K)进行不进位二进制加法运算结果
    {
		R11[i]=L10[i]+frk[i];
		if(R11[i]==2)
          R11[i]=0;
    }
//进行第十二次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R11[E[i-1]];
	for(i=1;i<=48;i++)//与K5按位作不进位加法运算
	  RE1[i]=RE1[i]+K5[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L12[i]=R11[i];
	for(i=1;i<33;i++)//R12为L11与f(R,K)进行不进位二进制加法运算结果
    {
		R12[i]=L11[i]+frk[i];
		if(R12[i]==2)
          R12[i]=0;
    }
//进行第十三次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R12[E[i-1]];
	for(i=1;i<=48;i++)//与K4按位作不进位加法运算
	  RE1[i]=RE1[i]+K4[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L13[i]=R12[i];
	for(i=1;i<33;i++)//R13为L12与f(R,K)进行不进位二进制加法运算结果
    {
		R13[i]=L12[i]+frk[i];
		if(R13[i]==2)
          R13[i]=0;
    }
//进行第十四次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R13[E[i-1]];
	for(i=1;i<=48;i++)//与K3按位作不进位加法运算
	  RE1[i]=RE1[i]+K3[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L14[i]=R13[i];
	for(i=1;i<33;i++)//R14为L13与f(R,K)进行不进位二进制加法运算结果
    {
		R14[i]=L13[i]+frk[i];
		if(R14[i]==2)
          R14[i]=0;
    }
//进行第十五次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R14[E[i-1]];
	for(i=1;i<=48;i++)//与K2按位作不进位加法运算
	  RE1[i]=RE1[i]+K2[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L15[i]=R14[i];
	for(i=1;i<33;i++)//R15为L14与f(R,K)进行不进位二进制加法运算结果
    {
		R15[i]=L14[i]+frk[i];
		if(R15[i]==2)
          R15[i]=0;
    }
//进行第十六次迭代
	for(i=1;i<=48;i++)//经过E变换扩充，由32位变为48位
	  RE1[i]=R15[E[i-1]];
	for(i=1;i<=48;i++)//与K1按位作不进位加法运算
	  RE1[i]=RE1[i]+K1[i];
	for(i=1;i<=48;i++)
    {
		if(RE1[i]==2)
          RE1[i]=0;
    }
	for(i=1;i<7;i++)//48位分成8组
	{
		s11[i]=RE1[i];
		s21[i]=RE1[i+6];
		s31[i]=RE1[i+12];
		s41[i]=RE1[i+18];
		s51[i]=RE1[i+24];
		s61[i]=RE1[i+30];
		s71[i]=RE1[i+36];
		s81[i]=RE1[i+42];
	}//下面经过S盒，得到8个数
	s[1]=s1[s11[6]+s11[1]*2][s11[5]+s11[4]*2+s11[3]*4+s11[2]*8];
	s[2]=s2[s21[6]+s21[1]*2][s21[5]+s21[4]*2+s21[3]*4+s21[2]*8];
	s[3]=s3[s31[6]+s31[1]*2][s31[5]+s31[4]*2+s31[3]*4+s31[2]*8];
	s[4]=s4[s41[6]+s41[1]*2][s41[5]+s41[4]*2+s41[3]*4+s41[2]*8];
	s[5]=s5[s51[6]+s51[1]*2][s51[5]+s51[4]*2+s51[3]*4+s51[2]*8];
	s[6]=s6[s61[6]+s61[1]*2][s61[5]+s61[4]*2+s61[3]*4+s61[2]*8];
	s[7]=s7[s71[6]+s71[1]*2][s71[5]+s71[4]*2+s71[3]*4+s71[2]*8];
	s[8]=s8[s81[6]+s81[1]*2][s81[5]+s81[4]*2+s81[3]*4+s81[2]*8];
	for(i=0;i<8;i++)//8个数变换输出二进制
	{
		for(j=1;j<5;j++)
		{
 		  temp[j]=s[i+1]%2;
		  s[i+1]=s[i+1]/2;
		}
		for(j=1;j<5;j++)
	      f[4*i+j]=temp[5-j];
	}
	for(i=1;i<33;i++)//经过P变换
	  frk[i]=f[P[i-1]];
	for(i=1;i<33;i++)//左右交换
      L16[i]=R15[i];
	for(i=1;i<33;i++)//R16为L15与f(R,K)进行不进位二进制加法运算结果
    {
		R16[i]=L15[i]+frk[i];
		if(R16[i]==2)
          R16[i]=0;
    }
	int t[65]; 
	for(i=1;i<=32;i++)
    {
		t[i]=R16[i];
		t[i+32]=L16[i];
	}
    for(i=1;i<=64;i++)
		t1[i]=t[IP_1[i-1]];
	int ch=0;
    m_YUANWEN=""; 
	for(i=0;i<=7;i++)
	{
      for(j=8;j>=1;j--)
	  {
         ch=ch+t1[i*8+j]*(int)pow(2,8-j);
	  }
	  m_YUANWEN=m_YUANWEN+(char)ch;
	  ch=0;
	}
	UpdateData(false);
}
