C51 COMPILER V9.53.0.0   IR_RECEIVE                                                        11/24/2020 12:40:26 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE IR_RECEIVE
OBJECT MODULE PLACED IN ..\IR_Receive.obj
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE IR_Receive.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2) OBJE
                    -CT(..\IR_Receive.obj)

line level    source

   1          
   2          #include "task.h"
   3          bit new_code;
   4          /*结构体*/      /* 保存一次解码后接收到的四字节数据*/
   5          static struct IR_data    //红外接收的数据结构
   6          {
   7              unsigned char addr1;     // 地址1(客户码1)
   8              unsigned char addr2;     // 地址2(客户码2)
   9              unsigned char data1;     // 数据1(数据码)
  10              unsigned char data2;     // 数据2(数据码反码)
  11          } IR_DATA;
  12          #define GTime 53                
  13          #define CTime 114               
  14          #define D0MinTime 4  
  15          #define D0MaxTime 9  
  16          #define D1MinTime 11  
  17          #define D1MaxTime 16             
  18          #define TimeOut_cnt 250 
  19          /*全局公共变量*/
  20           unsigned char T0_CNT;                // 定时器计数值
  21           unsigned char T0_CNT_bk;           // 计数备份
  22           bit TimeOut;                     // 超时标志
  23           bit Guide;                           // 引导码有效
  24           bit Continuous;                      // 连_发码
  25           unsigned char xdata IR_Time[33]; // 保存每两个下降沿之间的时间间隔
  26          uchar key_code;
  27          /*********************************************************************************************
  28          /*Timer1中断子程序*/
  29          void TR1_Service(void) interrupt 3 using 2
  30          {
  31   1          //static unsigned char  T;
  32   1        //  T++;
  33   1        //  if(T>1)
  34   1        //  {
  35   1            //  T=0;
  36   1              T0_CNT ++;
  37   1        //  }
  38   1          if(T0_CNT > TimeOut_cnt)
  39   1          {
  40   2              TimeOut = 1;       // 超时标志
  41   2          }
  42   1      }
  43          /***********************************************************************/
  44          /*解码核心程序*/
  45          void Decode(void)
  46          {
  47   1          unsigned char i=0x00,j,k;
  48   1          static unsigned char *p;  // 指向结构体IR_DATA.XX的指针
  49   1          EX1 = 0;   // 关外部中断1
  50   1          /*/////////////////////////进行解码处理////////////////////////*/
  51   1          p = &IR_DATA.addr1;
  52   1          for(k=0; k<4; k++)
  53   1          {
  54   2              for(j=0; j<8; j++)
C51 COMPILER V9.53.0.0   IR_RECEIVE                                                        11/24/2020 12:40:26 PAGE 2   

  55   2              {
  56   3                  if((IR_Time[i]>D0MinTime) & (IR_Time[i]<D0MaxTime))
  57   3                  {
  58   4                      *p >>= 1;           // 右移1位，
  59   4                      *p &= 0x7f;         // 与0111 1111置0. 数据“0” 0.56ms低电平+0.56ms高电平
  60   4                  }
  61   3                  else if((IR_Time[i]>D1MinTime) & (IR_Time[i]<D1MaxTime))
  62   3                  {
  63   4                      *p >>= 1;                // 右移1位，
  64   4                      *p |= 0x80;              // 或1000 0000置1. 数据“1” 0.56ms低电平+1.69ms高电平
  65   4                  }
  66   3                  i ++;
  67   3              }
  68   2              p ++;
  69   2          }
  70   1          if(IR_DATA.data2+IR_DATA.data1==0XFF)
  71   1          {
  72   2              key_code=IR_DATA.data1;
  73   2          new_code=1;
  74   2          }
  75   1          else
  76   1          {
  77   2              key_code=0XFF;   /**非本机遥控器或数据错误**/
  78   2          };
  79   1          /*/////////////////////////解码处理完毕////////////////////////*/
  80   1          EX1 = 1;   // 重新开放外部中断1
  81   1      } 
  82          void serviceINT0(void) interrupt 2 using 1  //{////外部中断1的中断函数。用于红外线读数。
  83          {
  84   1          static unsigned char m=0;
  85   1        TR1=1;
  86   1        
  87   1          T0_CNT_bk = T0_CNT;     // 备份时间计数值，即前一个下降沿到本下降沿的时间间隔
  88   1          T0_CNT = 0x00;          // 清空时间计数值
  89   1          if(TimeOut)             // 如果超时
  90   1          {
  91   2              //  TL0 = TIMER0_COUNT;     // 初始化定时器0       －0x1f（31）
  92   2              TimeOut = 0;        // 清除超时标志
  93   2              m = 0;              // 复位数据位
  94   2              T0_CNT = 0x00;      // 清空时间计数值
  95   2              Guide = 0;          // 清除引导标志
  96   2              Continuous = 0;     // 清除连_发标志
  97   2          }
  98   1          else       // 正常按键时长58.5ms～76.5ms
  99   1          {
 100   2              if(Guide | Continuous)          // 如果引导码有效
 101   2              {
 102   3                  IR_Time[m++] = T0_CNT_bk;       // 保存时间间隔
 103   3                  if(m == 32)   // 接收够32数据后
 104   3                  {
 105   4                      m = 0;
 106   4                      Guide = 0;    // 清除引导标志
 107   4               //new_code=1;
 108   4              TR1=0;
 109   4                      /*进行解码操作*/
 110   4                      Decode();     // 解码
 111   4                
 112   4                  }
 113   3              }
 114   2              if(T0_CNT_bk > GTime)   // 如果时间间隔>引导码时长
 115   2              {
 116   3                  Guide = 1;          // 使能引导标志
C51 COMPILER V9.53.0.0   IR_RECEIVE                                                        11/24/2020 12:40:26 PAGE 3   

 117   3                  m = 0;
 118   3              };
 119   2              if(T0_CNT_bk > CTime)    // 如果时间间隔>连_发码时长
 120   2              {
 121   3                  Continuous = 1;      // 使能连_发标志
 122   3                  m = 0;
 123   3              }
 124   2          }//end of 超时
 125   1      }
 126          /*********************************************************************************/
 127          /*************************************************************************************
 128          ************************************************************************************
 129          ***********************                                     ***************************
 130          ***********************    http://59tiaoba.taobao.com       ***************************
 131          ***********************                                     ***************************
 132          ************************************程序编写：Fucp****************************************
 133          **********************************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    414    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     44       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
